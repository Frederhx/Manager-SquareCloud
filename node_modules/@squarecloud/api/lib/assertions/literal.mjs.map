{"version":3,"sources":["../../src/assertions/literal.ts","../../src/structures/application/base.ts","../../src/modules/applications.ts","../../src/structures/error.ts","../../src/assertions/common.ts"],"sourcesContent":["import * as z from \"zod\";\n\nimport { assertLiteral } from \"./common\";\n\nconst StringSchema = z.coerce.string();\n\nconst BooleanSchema = z.coerce.boolean();\n\nconst PathLikeSchema = z.string().or(z.instanceof(Buffer));\n\nexport function assertString(\n\tvalue: unknown,\n\tcode?: string,\n): asserts value is string {\n\tassertLiteral({\n\t\tschema: StringSchema,\n\t\texpect: \"string\",\n\t\tvalue,\n\t\tcode,\n\t});\n}\n\nexport function assertBoolean(\n\tvalue: unknown,\n\tcode?: string,\n): asserts value is boolean {\n\tassertLiteral({\n\t\tschema: BooleanSchema,\n\t\texpect: \"boolean\",\n\t\tvalue,\n\t\tcode,\n\t});\n}\n\nexport function assertPathLike(\n\tvalue: unknown,\n\tcode?: string,\n): asserts value is string | Buffer {\n\tassertLiteral({\n\t\tschema: PathLikeSchema,\n\t\texpect: \"string or Buffer\",\n\t\tvalue,\n\t\tcode,\n\t});\n}\n","import type {\n\tAPIUserApplication,\n\tApplicationLanguage,\n} from \"@squarecloud/api-types/v2\";\nimport FormData from \"form-data\";\nimport { readFile } from \"fs/promises\";\n\nimport { assertPathLike, assertString } from \"@/assertions/literal\";\nimport type { SquareCloudAPI } from \"@/index\";\nimport { Routes } from \"@/lib/routes\";\nimport { BackupsModule, DeploysModule, FilesModule } from \"@/modules\";\nimport { ApplicationCacheService } from \"@/services\";\nimport { ApplicationStatus } from \"@/structures\";\nimport type { Application } from \"./application\";\n\n/**\n * Represents the base application from the user endpoint\n */\nexport class BaseApplication {\n\t/** The application ID */\n\tpublic readonly id: string;\n\t/** The application display name */\n\tpublic name: string;\n\t/** The application description */\n\tpublic description?: string;\n\t/** The url to manage the application via web */\n\tpublic url: string;\n\t/** The application total ram */\n\tpublic ram: number;\n\t/** The application current cluster */\n\tpublic cluster: string;\n\t/**\n\t * The application programming language\n\t *\n\t * - `javascript`\n\t * - `typescript`\n\t * - `python`\n\t * - `java`\n\t * - `elixir`\n\t * - `rust`\n\t * - `go`\n\t * - `php`\n\t * - `dotnet`\n\t * - `static`\n\t */\n\tpublic language: ApplicationLanguage;\n\n\t/** Cache service for this application */\n\tpublic readonly cache = new ApplicationCacheService();\n\t/** Files module for this application */\n\tpublic readonly files = new FilesModule(this);\n\t/** Backup module for this application */\n\tpublic readonly backups = new BackupsModule(this);\n\t/** Deploys module for this application */\n\tpublic readonly deploys = new DeploysModule(this);\n\n\t/**\n\t * Represents the base application from the user endpoint\n\t *\n\t * @constructor\n\t * @param client - The client for this application\n\t * @param data - The data from this application\n\t */\n\tconstructor(\n\t\tpublic readonly client: SquareCloudAPI,\n\t\tdata: APIUserApplication,\n\t) {\n\t\tconst { id, name, desc, ram, lang, cluster } = data;\n\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t\tthis.description = desc;\n\t\tthis.ram = ram;\n\t\tthis.language = lang;\n\t\tthis.cluster = cluster;\n\t\tthis.url = `https://squarecloud.app/dashboard/app/${id}`;\n\t}\n\n\t/** @deprecated Use `Application#backups` instead */\n\tget backup() {\n\t\tconsole.warn(\n\t\t\t\"Application#backup is deprecated. Use Application#backups instead.\",\n\t\t);\n\t\treturn this.backups;\n\t}\n\n\t/**\n\t * Fetches this application for full information\n\t */\n\tasync fetch(): Promise<Application> {\n\t\treturn this.client.applications.fetch(this.id);\n\t}\n\n\t/**\n\t * Gets the application current status information\n\t */\n\tasync getStatus(): Promise<ApplicationStatus> {\n\t\tconst data = await this.client.api.request(Routes.apps.status(this.id));\n\t\tconst status = new ApplicationStatus(this.client, data.response, this.id);\n\n\t\tthis.client.emit(\"statusUpdate\", this, this.cache.status, status);\n\t\tthis.cache.set(\"status\", status);\n\n\t\treturn status;\n\t}\n\n\t/**\n\t * Gets the application current logs\n\t */\n\tasync getLogs(): Promise<string> {\n\t\tconst data = await this.client.api.request(Routes.apps.logs(this.id));\n\t\tconst { logs } = data.response;\n\n\t\tthis.client.emit(\"logsUpdate\", this, this.cache.logs, logs);\n\t\tthis.cache.set(\"logs\", logs);\n\n\t\treturn logs;\n\t}\n\n\t/**\n\t * Starts up the application\n\t * @returns `boolean` for success or fail\n\t */\n\tasync start(): Promise<boolean> {\n\t\tconst data = await this.client.api.request(Routes.apps.start(this.id), {\n\t\t\tmethod: \"POST\",\n\t\t});\n\n\t\treturn data?.status === \"success\";\n\t}\n\n\t/**\n\t * Stops the application\n\t * @returns `boolean` for success or fail\n\t */\n\tasync stop(): Promise<boolean> {\n\t\tconst data = await this.client.api.request(Routes.apps.stop(this.id), {\n\t\t\tmethod: \"POST\",\n\t\t});\n\n\t\treturn data?.status === \"success\";\n\t}\n\n\t/**\n\t * Restarts the application\n\t * @returns `boolean` for success or fail\n\t */\n\tasync restart(): Promise<boolean> {\n\t\tconst data = await this.client.api.request(Routes.apps.restart(this.id), {\n\t\t\tmethod: \"POST\",\n\t\t});\n\n\t\treturn data?.status === \"success\";\n\t}\n\n\t/**\n\t * Deletes your whole application\n\t * - This action is irreversible.\n\t *\n\t * @returns `boolean` for success or fail\n\t */\n\tasync delete(): Promise<boolean> {\n\t\tconst data = await this.client.api.request(Routes.apps.delete(this.id), {\n\t\t\tmethod: \"DELETE\",\n\t\t});\n\n\t\treturn data?.status === \"success\";\n\t}\n\n\t/**\n\t * Commit files to your application folder\n\t *\n\t * - This action is irreversible.\n\t *\n\t * - Tip: use this to get an absolute path.\n\t * ```ts\n\t * require('path').join(__dirname, 'fileName')\n\t * ```\n\t * - Tip 2: use a zip file to commit more than one archive\n\t *\n\t * @param file - Buffer or absolute path to the file\n\t * @param fileName - The file name (e.g.: \"index.js\")\n\t * @param restart - Whether the application should be restarted after the commit\n\t * @returns `true` for success or `false` for fail\n\t */\n\tasync commit(file: string | Buffer, fileName?: string): Promise<boolean> {\n\t\tassertPathLike(file, \"COMMIT_DATA\");\n\n\t\tif (fileName) {\n\t\t\tassertString(fileName, \"FILE_NAME\");\n\t\t}\n\n\t\tif (typeof file === \"string\") {\n\t\t\tfile = await readFile(file);\n\t\t}\n\n\t\tconst formData = new FormData();\n\t\tformData.append(\"file\", file, { filename: fileName || \"app.zip\" });\n\n\t\tconst data = await this.client.api.request(Routes.apps.commit(this.id), {\n\t\t\tmethod: \"POST\",\n\t\t\tbody: formData.getBuffer(),\n\t\t\theaders: formData.getHeaders(),\n\t\t});\n\n\t\treturn data?.status === \"success\";\n\t}\n}\n","import type { RESTPostAPIApplicationUploadResult } from \"@squarecloud/api-types/v2\";\nimport FormData from \"form-data\";\nimport { readFile } from \"fs/promises\";\n\nimport { assertPathLike, assertString } from \"@/assertions/literal\";\nimport { Routes } from \"@/lib/routes\";\nimport {\n\tApplication,\n\ttype BaseApplication,\n\ttype Collection,\n\tSimpleApplicationStatus,\n\tSquareCloudAPIError,\n\tUser,\n} from \"@/structures\";\nimport type { SquareCloudAPI } from \"..\";\n\nexport class ApplicationsModule {\n\tconstructor(public readonly client: SquareCloudAPI) {}\n\n\t/**\n\t * If the ID is provided, it will return an application that you can manage or get information\n\t * If the ID is not provided, it will return a collection of applications\n\t *\n\t * @param applicationId - The application ID, you must own the application\n\t */\n\tasync get(): Promise<Collection<string, BaseApplication>>;\n\tasync get(applicationId: string): Promise<BaseApplication>;\n\tasync get(\n\t\tapplicationId?: string,\n\t): Promise<BaseApplication | Collection<string, BaseApplication>> {\n\t\tconst { response } = await this.client.api.request(Routes.user());\n\t\tconst user = new User(this.client, response);\n\n\t\tthis.client.emit(\"userUpdate\", this.client.cache.user, user);\n\t\tthis.client.cache.set(\"user\", user);\n\n\t\tif (applicationId) {\n\t\t\tassertString(applicationId, \"APP_ID\");\n\t\t\tconst application = user.applications.get(applicationId);\n\n\t\t\tif (!application) {\n\t\t\t\tthrow new SquareCloudAPIError(\"APP_NOT_FOUND\");\n\t\t\t}\n\n\t\t\treturn application;\n\t\t}\n\n\t\treturn user.applications;\n\t}\n\n\t/**\n\t * Uploads an application\n\t *\n\t * @param file - The zip file path or Buffer\n\t *\n\t * @returns The uploaded application data\n\t */\n\tasync create(\n\t\tfile: string | Buffer,\n\t): Promise<RESTPostAPIApplicationUploadResult> {\n\t\tassertPathLike(file, \"COMMIT_DATA\");\n\n\t\tif (typeof file === \"string\") {\n\t\t\tfile = await readFile(file);\n\t\t}\n\n\t\tconst formData = new FormData();\n\t\tformData.append(\"file\", file, { filename: \"app.zip\" });\n\n\t\tconst data = await this.client.api.request(Routes.apps.upload(), {\n\t\t\tmethod: \"POST\",\n\t\t\tbody: formData.getBuffer(),\n\t\t\theaders: formData.getHeaders(),\n\t\t});\n\n\t\treturn data.response;\n\t}\n\n\t/**\n\t * Gets the summary status for all your applications\n\t */\n\tasync statusAll(): Promise<SimpleApplicationStatus[]> {\n\t\tconst data = await this.client.api.request(Routes.apps.statusAll());\n\n\t\treturn data.response.map(\n\t\t\t(status) => new SimpleApplicationStatus(this.client, status),\n\t\t);\n\t}\n\n\t/**\n\t * Returns an application that you can manage or get information\n\t *\n\t * @param applicationId - The application ID, you must own the application\n\t */\n\tasync fetch(applicationId: string): Promise<Application> {\n\t\tconst { response } = await this.client.api.request(\n\t\t\tRoutes.apps.info(applicationId),\n\t\t);\n\n\t\treturn new Application(this.client, response);\n\t}\n}\n\nexport * from \"./backups\";\nexport * from \"../services/cache/application\";\nexport * from \"./deploys\";\nexport * from \"./files\";\nexport * from \"./network\";\n","export class SquareCloudAPIError extends TypeError {\n\tconstructor(\n\t\tcode: string,\n\t\tmessage?: string,\n\t\toptions?: { stack?: string; cause?: unknown },\n\t) {\n\t\tsuper(code);\n\n\t\tthis.name = \"SquareCloudAPIError\";\n\n\t\tthis.message =\n\t\t\t(code\n\t\t\t\t?.replaceAll(\"_\", \" \")\n\t\t\t\t.toLowerCase()\n\t\t\t\t.replace(/(^|\\s)\\S/g, (L) => L.toUpperCase()) || \"UNKNOWN_CODE\") +\n\t\t\t(message ? `: ${message}` : \"\");\n\n\t\tif (options?.stack) {\n\t\t\tthis.stack = options.stack;\n\t\t}\n\n\t\tif (options?.cause) {\n\t\t\tthis.cause = options.cause;\n\t\t}\n\t}\n}\n","import type { LiteralAssertionProps } from \"@/types/assertions\";\nimport { SquareCloudAPIError } from \"../structures\";\n\nexport function assertLiteral({\n\tschema,\n\tvalue,\n\texpect,\n\tcode,\n}: LiteralAssertionProps) {\n\ttry {\n\t\tschema.parse(value);\n\t} catch {\n\t\tthrow new SquareCloudAPIError(\n\t\t\tcode ? `INVALID_${code}` : \"VALIDATION_ERROR\",\n\t\t\t`Expect ${expect}, got ${typeof value}`,\n\t\t);\n\t}\n}\n"],"mappings":";AAAA,YAAY,OAAO;;;ACInB,OAAOA,eAAc;;;ACHrB,OAAO,cAAc;;;ACDd,IAAM,sBAAN,cAAkC,UAAU;AAAA,EAClD,YACC,MACA,SACA,SACC;AACD,UAAM,IAAI;AAEV,SAAK,OAAO;AAEZ,SAAK,WACH,MACE,WAAW,KAAK,GAAG,EACpB,YAAY,EACZ,QAAQ,aAAa,CAAC,MAAM,EAAE,YAAY,CAAC,KAAK,mBACjD,UAAU,KAAK,OAAO,KAAK;AAE7B,QAAI,SAAS,OAAO;AACnB,WAAK,QAAQ,QAAQ;AAAA,IACtB;AAEA,QAAI,SAAS,OAAO;AACnB,WAAK,QAAQ,QAAQ;AAAA,IACtB;AAAA,EACD;AACD;;;ACtBO,SAAS,cAAc;AAAA,EAC7B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACD,GAA0B;AACzB,MAAI;AACH,WAAO,MAAM,KAAK;AAAA,EACnB,QAAQ;AACP,UAAM,IAAI;AAAA,MACT,OAAO,WAAW,IAAI,KAAK;AAAA,MAC3B,UAAU,MAAM,SAAS,OAAO,KAAK;AAAA,IACtC;AAAA,EACD;AACD;;;AJbA,IAAM,eAAiB,SAAO,OAAO;AAErC,IAAM,gBAAkB,SAAO,QAAQ;AAEvC,IAAM,iBAAmB,SAAO,EAAE,GAAK,aAAW,MAAM,CAAC;AAElD,SAAS,aACf,OACA,MAC0B;AAC1B,gBAAc;AAAA,IACb,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR;AAAA,IACA;AAAA,EACD,CAAC;AACF;AAEO,SAAS,cACf,OACA,MAC2B;AAC3B,gBAAc;AAAA,IACb,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR;AAAA,IACA;AAAA,EACD,CAAC;AACF;AAEO,SAAS,eACf,OACA,MACmC;AACnC,gBAAc;AAAA,IACb,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR;AAAA,IACA;AAAA,EACD,CAAC;AACF;","names":["FormData"]}